#!/usr/bin/env python3
"""
Bridge Registry - Multi-bridge coordination management
Supports multiple simultaneous bridges with cleanup
"""

import json
import subprocess
import sys
import uuid
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Tuple


class BridgeRegistry:
    """Manages multiple coordination bridges and cleanup"""

    def __init__(self, coord_dir: str = ".ai-coordination"):
        self.coord_dir = Path(coord_dir)
        self.registry_dir = self.coord_dir / "registry"
        self.bridges_dir = self.registry_dir / "bridges"
        self.sessions_dir = self.registry_dir / "sessions"
        self.messages_dir = self.coord_dir / "messages"
        self.cleanup_dir = self.coord_dir / "cleanup"

        # Create directory structure
        self._setup_directories()

    def _setup_directories(self):
        """Create the multi-bridge directory structure"""
        dirs = [
            self.coord_dir,
            self.registry_dir,
            self.bridges_dir,
            self.sessions_dir,
            self.messages_dir,
            self.cleanup_dir,
        ]

        for directory in dirs:
            directory.mkdir(exist_ok=True)

    def create_bridge(self, session1: str, session2: str, context: str) -> str:
        """Create a new bridge between two sessions"""
        bridge_id = f"bridge-{uuid.uuid4().hex[:12]}"

        bridge_config = {
            "bridge_id": bridge_id,
            "session1": session1,
            "session2": session2,
            "coordination_context": context,
            "created_at": datetime.now().isoformat(),
            "status": "active",
            "last_activity": datetime.now().isoformat(),
        }

        # Write bridge config
        bridge_file = self.bridges_dir / f"{bridge_id}.json"
        with open(bridge_file, "w") as f:
            json.dump(bridge_config, f, indent=2)

        # Update session mappings
        self._add_session_to_bridge(session1, bridge_id)
        self._add_session_to_bridge(session2, bridge_id)

        # Create message directory for this bridge
        bridge_msg_dir = self.messages_dir / bridge_id
        bridge_msg_dir.mkdir(exist_ok=True)

        # Update active bridges index
        self._update_active_bridges()

        # Update legacy bridge_context.json for backwards compatibility
        self._update_legacy_config(bridge_config)

        # Generate communication scripts
        self._generate_communication_scripts(session1, session2, bridge_id)

        print(f"âœ… Bridge created: {bridge_id}")
        print(f"   {session1} â†” {session2}")
        print(f"   Context: {context}")
        print(f"   ğŸ“¤ Scripts: send-to-peer-{session1}.sh, send-to-peer-{session2}.sh")

        # ISSUE FIX: Send context notification to both tmux sessions
        self._notify_sessions_of_bridge(session1, session2, context, bridge_id)

        return bridge_id

    def _add_session_to_bridge(self, session: str, bridge_id: str):
        """Add a session to a bridge mapping"""
        session_file = self.sessions_dir / f"{session}.json"

        if session_file.exists():
            with open(session_file, "r") as f:
                session_data = json.load(f)
        else:
            session_data = {
                "session_name": session,
                "bridges": [],
                "created_at": datetime.now().isoformat(),
            }

        if bridge_id not in session_data["bridges"]:
            session_data["bridges"].append(bridge_id)
            session_data["last_updated"] = datetime.now().isoformat()

        with open(session_file, "w") as f:
            json.dump(session_data, f, indent=2)

    def _update_active_bridges(self):
        """Update the active bridges index"""
        active_bridges = []

        for bridge_file in self.bridges_dir.glob("*.json"):
            try:
                with open(bridge_file, "r") as f:
                    bridge_data = json.load(f)

                if bridge_data.get("status") == "active":
                    active_bridges.append(
                        {
                            "bridge_id": bridge_data["bridge_id"],
                            "session1": bridge_data["session1"],
                            "session2": bridge_data["session2"],
                            "context": bridge_data["coordination_context"],
                            "created_at": bridge_data["created_at"],
                            "last_activity": bridge_data.get("last_activity", bridge_data["created_at"]),
                        }
                    )
            except Exception as e:
                print(f"âš ï¸  Warning: Could not read bridge file {bridge_file}: {e}")

        index_file = self.registry_dir / "active-bridges.json"
        with open(index_file, "w") as f:
            json.dump(
                {
                    "active_bridges": active_bridges,
                    "total_bridges": len(active_bridges),
                    "last_updated": datetime.now().isoformat(),
                },
                f,
                indent=2,
            )

    def _update_legacy_config(self, bridge_config: Dict):
        """Update legacy bridge_context.json for backwards compatibility"""
        legacy_file = self.coord_dir / "bridge_context.json"
        with open(legacy_file, "w") as f:
            json.dump(
                {
                    "session1": bridge_config["session1"],
                    "session2": bridge_config["session2"],
                    "coordination_context": bridge_config["coordination_context"],
                    "created_at": bridge_config["created_at"],
                    "bridge_id": bridge_config["bridge_id"],
                    "_note": "Legacy compatibility - use bridge registry for multi-bridge support",
                },
                f,
                indent=2,
            )

    def list_bridges(self) -> List[Dict[str, Any]]:
        """List all active bridges"""
        index_file = self.registry_dir / "active-bridges.json"

        if not index_file.exists():
            self._update_active_bridges()

        with open(index_file, "r") as f:
            data = json.load(f)

        bridges_data = data.get("active_bridges", [])
        return list(bridges_data)

    def get_session_bridges(self, session: str) -> List[str]:
        """Get all bridges a session participates in"""
        session_file = self.sessions_dir / f"{session}.json"

        if not session_file.exists():
            return []

        with open(session_file, "r") as f:
            session_data = json.load(f)

        bridges_list = session_data.get("bridges", [])
        return list(bridges_list)

    def find_peer_sessions(self, session: str) -> List[Tuple[str, str]]:
        """Find all peer sessions for a given session"""
        peers = []
        bridges = self.get_session_bridges(session)

        for bridge_id in bridges:
            bridge_file = self.bridges_dir / f"{bridge_id}.json"
            if bridge_file.exists():
                with open(bridge_file, "r") as f:
                    bridge_data = json.load(f)

                if bridge_data["session1"] == session:
                    peers.append((bridge_data["session2"], bridge_id))
                elif bridge_data["session2"] == session:
                    peers.append((bridge_data["session1"], bridge_id))

        return peers

    def _generate_communication_scripts(self, session1: str, session2: str, bridge_id: str):
        """Generate send-to-peer scripts for bridge communication"""
        # Script for session1 to send to session2
        script1_content = f"""#!/bin/bash
# Send message from {session1} to {session2} via bridge {bridge_id}
MESSAGE="$1"
if [ -z "$MESSAGE" ]; then
    echo "Usage: $0 <message>"
    exit 1
fi

MESSAGE_ID="{session1}-$(date +%s%N | cut -c1-13)"
cat > .ai-coordination/messages/${{MESSAGE_ID}}.json << EOF
{{
  "from_session": "{session1}",
  "to_session": "{session2}",
  "message": "$MESSAGE",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")",
  "message_id": "$MESSAGE_ID",
  "bridge_id": "{bridge_id}"
}}
EOF

echo "âœ… Message sent to {session2}: $MESSAGE"
# Notify peer session about new message
tmux send-keys -t "{session2}:0.0" "ğŸ“¨ New message from {session1}: $(printf '%q' "$MESSAGE")" Enter 2>/dev/null || true
"""

        # Script for session2 to send to session1
        script2_content = f"""#!/bin/bash
# Send message from {session2} to {session1} via bridge {bridge_id}
MESSAGE="$1"
if [ -z "$MESSAGE" ]; then
    echo "Usage: $0 <message>"
    exit 1
fi

MESSAGE_ID="{session2}-$(date +%s%N | cut -c1-13)"
cat > .ai-coordination/messages/${{MESSAGE_ID}}.json << EOF
{{
  "from_session": "{session2}",
  "to_session": "{session1}",
  "message": "$MESSAGE",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")",
  "message_id": "$MESSAGE_ID",
  "bridge_id": "{bridge_id}"
}}
EOF

echo "âœ… Message sent to {session1}: $MESSAGE"
# Notify peer session about new message
tmux send-keys -t "{session1}:0.0" "ğŸ“¨ New message from {session2}: $(printf '%q' "$MESSAGE")" Enter 2>/dev/null || true
"""

        # Write script files
        script1_path = Path(f"send-to-peer-{session1}.sh")
        script2_path = Path(f"send-to-peer-{session2}.sh")

        with open(script1_path, "w") as f:
            f.write(script1_content)
        with open(script2_path, "w") as f:
            f.write(script2_content)

        # Make scripts executable
        script1_path.chmod(0o755)
        script2_path.chmod(0o755)

    def _notify_sessions_of_bridge(self, session1: str, session2: str, context: str, bridge_id: str):
        """Send context notification to both tmux sessions when bridge is created"""
        # Format as a shell comment to avoid command errors
        notification_lines = [
            "# ğŸ”— BRIDGE ESTABLISHED",
            f"# Bridge ID: {bridge_id}",
            f"# Connected to: {session2 if session1 != session2 else session1}",
            f"# Context: {context}",
            f"# Use 'ai-bridge send {session2}' to communicate",
        ]

        # Try to notify session1 (use :0.0 for orchestrator pane)
        try:
            import subprocess

            # Send each line as a comment
            for line in notification_lines:
                subprocess.run(
                    ["tmux", "send-keys", "-t", f"{session1}:0.0", "-l", line], check=False, capture_output=True
                )
                subprocess.run(["tmux", "send-keys", "-t", f"{session1}:0.0", "C-m"], check=False, capture_output=True)
            print(f"   ğŸ“¤ Context sent to {session1}")
        except Exception:
            print(f"   âš ï¸  Could not notify {session1} (session may not exist)")

        # Prepare notification for session2
        notification_lines2 = [
            "# ğŸ”— BRIDGE ESTABLISHED",
            f"# Bridge ID: {bridge_id}",
            f"# Connected to: {session1}",
            f"# Context: {context}",
            f"# Use 'ai-bridge send {session1}' to communicate",
        ]

        # Try to notify session2
        try:
            # Send each line as a comment
            for line in notification_lines2:
                subprocess.run(
                    ["tmux", "send-keys", "-t", f"{session2}:0.0", "-l", line], check=False, capture_output=True
                )
                subprocess.run(["tmux", "send-keys", "-t", f"{session2}:0.0", "C-m"], check=False, capture_output=True)
            print(f"   ğŸ“¤ Context sent to {session2}")
        except Exception:
            print(f"   âš ï¸  Could not notify {session2} (session may not exist)")

    def cleanup_old_bridges(
        self, max_age_days: int = 0, dry_run: bool = False, complete: bool = False
    ) -> Dict[str, Any]:
        """Clean up old bridges and messages"""
        cutoff_time = datetime.now() - timedelta(days=max_age_days)
        cleanup_stats = {
            "bridges_removed": 0,
            "messages_removed": 0,
            "sessions_removed": 0,
            "space_freed": 0,
            "errors": [],
        }

        if complete:
            # Complete cleanup - remove all coordination files
            self._complete_cleanup(cleanup_stats, dry_run)
        else:
            # Age-based cleanup - only remove old bridges
            # Process each bridge file
            for bridge_file in self.bridges_dir.glob("*.json"):
                self._process_bridge_file(bridge_file, cutoff_time, cleanup_stats, dry_run)

        if not dry_run:
            self._finalize_cleanup(cleanup_stats, max_age_days if not complete else "complete")

        return cleanup_stats

    def _cleanup_all_bridge_files(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Remove all bridge files during complete cleanup"""
        for bridge_file in self.bridges_dir.glob("*.json"):
            if not dry_run:
                try:
                    space_freed = cleanup_stats["space_freed"]
                    cleanup_stats["space_freed"] = space_freed + int(bridge_file.stat().st_size)
                    bridge_file.unlink()
                except Exception as e:
                    cleanup_stats["errors"].append(f"Error removing bridge {bridge_file}: {e}")
            cleanup_stats["bridges_removed"] += 1
            print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} bridge: {bridge_file.name}")

    def _cleanup_all_session_files(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Remove all session files during complete cleanup"""
        for session_file in self.sessions_dir.glob("*.json"):
            if not dry_run:
                try:
                    space_freed = cleanup_stats["space_freed"]
                    cleanup_stats["space_freed"] = space_freed + int(session_file.stat().st_size)
                    session_file.unlink()
                except Exception as e:
                    cleanup_stats["errors"].append(f"Error removing session {session_file}: {e}")
            cleanup_stats["sessions_removed"] += 1
            print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} session: {session_file.name}")

    def _cleanup_message_directory(self, msg_dir: Path, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Clean up message files in a directory"""
        for msg_file in msg_dir.glob("*.json"):
            if not dry_run:
                try:
                    space_freed = cleanup_stats["space_freed"]
                    cleanup_stats["space_freed"] = space_freed + int(msg_file.stat().st_size)
                    msg_file.unlink()
                except Exception as e:
                    cleanup_stats["errors"].append(f"Error removing message {msg_file}: {e}")
            cleanup_stats["messages_removed"] += 1
            print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} message: {msg_file.name}")

        # Remove the directory if empty or in complete cleanup
        if not dry_run:
            try:
                msg_dir.rmdir()
                print(f"ğŸ—‘ï¸  Removed message directory: {msg_dir.name}")
            except OSError:
                # Directory not empty or other error - that's ok
                pass

    def _cleanup_message_file(self, msg_file: Path, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Clean up a single message file"""
        if not dry_run:
            try:
                space_freed = cleanup_stats["space_freed"]
                cleanup_stats["space_freed"] = space_freed + int(msg_file.stat().st_size)
                msg_file.unlink()
            except Exception as e:
                cleanup_stats["errors"].append(f"Error removing message {msg_file}: {e}")
        cleanup_stats["messages_removed"] += 1
        print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} message: {msg_file.name}")

    def _cleanup_all_message_files(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Remove all message files and directories during complete cleanup"""
        for msg_dir in self.messages_dir.iterdir():
            if msg_dir.is_dir():
                self._cleanup_message_directory(msg_dir, cleanup_stats, dry_run)
            elif msg_dir.is_file() and msg_dir.suffix == ".json":
                self._cleanup_message_file(msg_dir, cleanup_stats, dry_run)

    def _cleanup_registry_files(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Remove registry and legacy files during complete cleanup"""
        # Remove registry index files
        registry_files = ["active-bridges.json"]
        for registry_file in registry_files:
            file_path = self.registry_dir / registry_file
            if file_path.exists():
                if not dry_run:
                    try:
                        space_freed = cleanup_stats["space_freed"]
                        cleanup_stats["space_freed"] = space_freed + int(file_path.stat().st_size)
                        file_path.unlink()
                    except Exception as e:
                        cleanup_stats["errors"].append(f"Error removing registry file {registry_file}: {e}")
                print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} registry file: {registry_file}")

        # Remove legacy bridge context file
        legacy_context = self.coord_dir / "bridge_context.json"
        if legacy_context.exists():
            if not dry_run:
                try:
                    space_freed = cleanup_stats["space_freed"]
                    cleanup_stats["space_freed"] = space_freed + int(legacy_context.stat().st_size)
                    legacy_context.unlink()
                except Exception as e:
                    cleanup_stats["errors"].append(f"Error removing legacy context: {e}")
            print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} legacy bridge_context.json")

    def _complete_cleanup(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Perform complete cleanup of all coordination files"""
        self._cleanup_all_bridge_files(cleanup_stats, dry_run)
        self._cleanup_all_session_files(cleanup_stats, dry_run)
        self._cleanup_all_message_files(cleanup_stats, dry_run)
        self._cleanup_registry_files(cleanup_stats, dry_run)
        self._cleanup_all_generated_scripts(cleanup_stats, dry_run)

    def _process_bridge_file(self, bridge_file, cutoff_time, cleanup_stats, dry_run):
        """Process a single bridge file for cleanup"""
        try:
            with open(bridge_file, "r") as f:
                bridge_data = json.load(f)

            last_activity = datetime.fromisoformat(bridge_data.get("last_activity", bridge_data["created_at"]))

            if last_activity < cutoff_time:
                bridge_id = bridge_data["bridge_id"]
                self._remove_old_bridge(bridge_file, bridge_data, cleanup_stats, dry_run)
                print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} old bridge: {bridge_id}")

        except Exception as e:
            error_list = cleanup_stats["errors"]
            if isinstance(error_list, list):
                error_list.append(f"Error processing {bridge_file}: {e}")

    def _remove_old_bridge(self, bridge_file, bridge_data, cleanup_stats, dry_run):
        """Remove an old bridge and its associated data"""
        bridge_id = bridge_data["bridge_id"]

        if not dry_run:
            # Remove bridge config
            bridge_file.unlink()

            # Remove message directory
            self._cleanup_bridge_messages(bridge_id, cleanup_stats)

            # Update session mappings
            self._remove_bridge_from_sessions(bridge_id)

            # Remove generated communication scripts
            self._cleanup_bridge_scripts(bridge_data["session1"], bridge_data["session2"], bridge_id)

        # Update stats
        bridges_removed = cleanup_stats["bridges_removed"]
        if isinstance(bridges_removed, int):
            cleanup_stats["bridges_removed"] = bridges_removed + 1

    def _cleanup_bridge_messages(self, bridge_id, cleanup_stats):
        """Clean up message files for a bridge"""
        msg_dir = self.messages_dir / bridge_id
        if msg_dir.exists():
            for msg_file in msg_dir.glob("*.json"):
                space_freed = cleanup_stats["space_freed"]
                if isinstance(space_freed, int):
                    cleanup_stats["space_freed"] = space_freed + int(msg_file.stat().st_size)
                msg_file.unlink()
                messages_removed = cleanup_stats["messages_removed"]
                if isinstance(messages_removed, int):
                    cleanup_stats["messages_removed"] = messages_removed + 1
            msg_dir.rmdir()

    def _finalize_cleanup(self, cleanup_stats, max_age_days):
        """Finalize cleanup by updating indexes and logging"""
        # Update active bridges index
        self._update_active_bridges()

        # Record cleanup
        cleanup_log = self.cleanup_dir / "last-cleanup.json"
        with open(cleanup_log, "w") as f:
            json.dump(
                {
                    "cleanup_time": datetime.now().isoformat(),
                    "max_age_days": max_age_days,
                    "stats": cleanup_stats,
                },
                f,
                indent=2,
            )

    def _remove_bridge_from_sessions(self, bridge_id: str):
        """Remove bridge from all session mappings"""
        for session_file in self.sessions_dir.glob("*.json"):
            try:
                with open(session_file, "r") as f:
                    session_data = json.load(f)

                if bridge_id in session_data.get("bridges", []):
                    session_data["bridges"].remove(bridge_id)
                    session_data["last_updated"] = datetime.now().isoformat()

                    with open(session_file, "w") as f:
                        json.dump(session_data, f, indent=2)

            except Exception as e:
                print(f"âš ï¸  Warning: Could not update session file {session_file}: {e}")

    def _cleanup_bridge_scripts(self, session1: str, session2: str, bridge_id: str):
        """Remove generated communication scripts for a bridge"""
        scripts_to_remove = [f"send-to-peer-{session1}.sh", f"send-to-peer-{session2}.sh"]

        for script_name in scripts_to_remove:
            script_path = Path(script_name)
            if script_path.exists():
                try:
                    script_path.unlink()
                    print(f"   ğŸ—‘ï¸  Removed script: {script_name}")
                except Exception as e:
                    print(f"   âš ï¸  Could not remove script {script_name}: {e}")

        # Notify sessions that bridge was removed
        removal_msg = f"""ğŸ”— BRIDGE REMOVED
Bridge ID: {bridge_id}
Connection to {'each other' if session1 != session2 else 'self'} has been terminated.
Use 'ai-bridge list' to see remaining connections."""

        # Try to notify both sessions
        for session in [session1, session2]:
            try:
                subprocess.run(
                    ["tmux", "send-keys", "-t", f"{session}:0.0", "-l", removal_msg], check=False, capture_output=True
                )
                subprocess.run(["tmux", "send-keys", "-t", f"{session}:0.0", "C-m"], check=False, capture_output=True)
            except Exception:
                pass  # Session may not exist, which is fine

    def _cleanup_all_generated_scripts(self, cleanup_stats: Dict[str, Any], dry_run: bool) -> None:
        """Remove all generated send-to-peer scripts"""
        script_pattern = "send-to-peer-*.sh"
        import glob

        scripts = glob.glob(script_pattern)
        for script_path in scripts:
            script_file = Path(script_path)
            if script_file.exists():
                if not dry_run:
                    try:
                        space_freed = cleanup_stats["space_freed"]
                        cleanup_stats["space_freed"] = space_freed + int(script_file.stat().st_size)
                        script_file.unlink()
                    except Exception as e:
                        cleanup_stats["errors"].append(f"Error removing script {script_path}: {e}")
                print(f"ğŸ—‘ï¸  {'Would remove' if dry_run else 'Removed'} script: {script_path}")


def show_help():
    """Display comprehensive CLI help with examples"""
    print(
        """ğŸ”— Bridge Registry - Multi-Team Coordination Manager

USAGE:
    bridge_registry.py <command> [options]

COMMANDS:
    create <session1> <session2> "<context>"     Create bridge between sessions
    list                                         List all active bridges
    cleanup [--dry-run] [--complete|--all]     Clean up coordination files
    cleanup [--dry-run] [--max-age-days N]     Clean up bridges older than N days
    status <session>                            Show bridges for a session
    help                                        Show this help

PRACTICAL EXAMPLES:
    # ğŸš€ QUICK START - Connect two teams
    bridge_registry.py create frontend-team backend-team "API coordination"

    # ğŸ“‹ See all active bridges
    bridge_registry.py list

    # ğŸ” Check what bridges a team has
    bridge_registry.py status mobile-team

    # ğŸ§¹ Clean up bridges (safe mode first!)
    bridge_registry.py cleanup --dry-run
    bridge_registry.py cleanup

COORDINATION WORKFLOW:
    1. ğŸ”— Create:    bridge_registry.py create team-a team-b "shared context"
    2. ğŸ“¤ Send:      send-to-peer-team-a.sh "Hello team-b!"
    3. ğŸ“¥ Check:     check-peer-messages.sh
    4. ğŸ“Š Monitor:   bridge_registry.py status team-a
    5. ğŸ§¹ Cleanup:   bridge_registry.py cleanup --dry-run

REAL-WORLD USE CASES:
    â€¢ Mobile â†” Web teams coordinating UI consistency
    â€¢ Frontend â†” Backend teams syncing API changes
    â€¢ DevOps â†” Security teams sharing deployment info
    â€¢ Research â†” Production teams transferring models

FILES CREATED:
    .ai-coordination/registry/         Bridge registry and session tracking
    send-to-peer-<session>.sh         Message sending scripts
    check-peer-messages.sh             Message checking script
    bridge-status.sh                   Bridge status script
"""
    )


def handle_create_command(registry: BridgeRegistry) -> None:
    """Handle create command"""
    if len(sys.argv) >= 5:
        registry.create_bridge(sys.argv[2], sys.argv[3], " ".join(sys.argv[4:]))
    else:
        print("âŒ Usage: ai-bridge-old create <session1> <session2> <context>")
        sys.exit(1)


def handle_list_command(registry: BridgeRegistry) -> None:
    """Handle list command"""
    bridges = registry.list_bridges()
    print(f"ğŸ“‹ Active Bridges ({len(bridges)}):")
    for bridge in bridges:
        print(f"  ğŸ”— {bridge['bridge_id']}")
        print(f"     {bridge['session1']} â†” {bridge['session2']}")
        print(f"     Context: {bridge['context']}")
        print(f"     Created: {bridge['created_at']}")
        print()


def handle_cleanup_command(registry: BridgeRegistry) -> None:
    """Handle cleanup command"""
    dry_run = "--dry-run" in sys.argv
    complete = "--complete" in sys.argv or "--all" in sys.argv
    max_age = 0  # Default to cleaning up all bridges

    if "--max-age-days" in sys.argv:
        idx = sys.argv.index("--max-age-days")
        if idx + 1 < len(sys.argv):
            max_age = int(sys.argv[idx + 1])

    # If complete cleanup is requested or no specific age is given, do complete cleanup
    if complete or max_age == 0:
        complete = True
        cleanup_type = "COMPLETE" if not dry_run else "COMPLETE (DRY RUN)"
    else:
        cleanup_type = f"AGE-BASED {'(DRY RUN)' if dry_run else ''}"

    stats = registry.cleanup_old_bridges(max_age, dry_run, complete)
    print(f"ğŸ—‘ï¸  Cleanup {cleanup_type}:")
    print(f"   Bridges removed: {stats['bridges_removed']}")
    print(f"   Sessions removed: {stats['sessions_removed']}")
    print(f"   Messages removed: {stats['messages_removed']}")
    print(f"   Space freed: {stats['space_freed']} bytes")
    if stats["errors"]:
        print(f"   Errors: {len(stats['errors'])}")
        for error in stats["errors"]:
            print(f"     - {error}")


def handle_status_command(registry: BridgeRegistry) -> None:
    """Handle status command"""
    if len(sys.argv) >= 3:
        session = sys.argv[2]
        peers = registry.find_peer_sessions(session)
        print(f"ğŸ“ Session '{session}' bridges:")
        for peer, bridge_id in peers:
            print(f"   {session} â†” {peer} (via {bridge_id})")
    else:
        print("âŒ Usage: ai-bridge-old status <session>")
        sys.exit(1)


def main():
    """CLI interface for bridge registry"""
    if len(sys.argv) < 2 or (len(sys.argv) >= 2 and sys.argv[1] in ["help", "--help", "-h"]):
        show_help()
        sys.exit(0)

    registry = BridgeRegistry()
    command = sys.argv[1]

    if command == "create":
        handle_create_command(registry)
    elif command == "list":
        handle_list_command(registry)
    elif command == "cleanup":
        handle_cleanup_command(registry)
    elif command == "status":
        handle_status_command(registry)
    else:
        print(f"âŒ Unknown command: '{command}'")
        print("\nğŸ’¡ Try: bridge_registry.py help")
        print('ğŸš€ Quick start: bridge_registry.py create team1 team2 "coordination context"')
        sys.exit(1)


if __name__ == "__main__":
    main()
